//------------------------------------------------------------------------------
// <auto-generated>
//     Dieser Code wurde von einem Tool generiert.
//     Laufzeitversion:4.0.30319.42000
//
//     Änderungen an dieser Datei können falsches Verhalten verursachen und gehen verloren, wenn
//     der Code erneut generiert wird.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Cluster.Properties {
    using System;
    
    
    /// <summary>
    ///   Eine stark typisierte Ressourcenklasse zum Suchen von lokalisierten Zeichenfolgen usw.
    /// </summary>
    // Diese Klasse wurde von der StronglyTypedResourceBuilder automatisch generiert
    // -Klasse über ein Tool wie ResGen oder Visual Studio automatisch generiert.
    // Um einen Member hinzuzufügen oder zu entfernen, bearbeiten Sie die .ResX-Datei und führen dann ResGen
    // mit der /str-Option erneut aus, oder Sie erstellen Ihr VS-Projekt neu.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    public class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Gibt die zwischengespeicherte ResourceManager-Instanz zurück, die von dieser Klasse verwendet wird.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        public static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Cluster.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Überschreibt die CurrentUICulture-Eigenschaft des aktuellen Threads für alle
        ///   Ressourcenzuordnungen, die diese stark typisierte Ressourcenklasse verwenden.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        public static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die  ähnelt.
        /// </summary>
        public static string atmosphere_frag {
            get {
                return ResourceManager.GetString("atmosphere_frag", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die  ähnelt.
        /// </summary>
        public static string atmosphere_geom {
            get {
                return ResourceManager.GetString("atmosphere_geom", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die  ähnelt.
        /// </summary>
        public static string atmosphere_vert {
            get {
                return ResourceManager.GetString("atmosphere_vert", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die #version 420 core
        ///
        ///
        ///uniform vec3 rgb;
        ///uniform float size;
        ///uniform vec3 info;
        ///
        /////
        ///
        ///in float pass_height;
        ///in vec3 pass_color;
        ///
        ///out vec4 out_Color;
        ///
        ///void main(void)
        ///{
        ///	//if ( pass_height &gt; info.y) discard;
        ///	out_Color = vec4(pass_color*rgb, info.z);
        ///}
        ////*
        ///in GS_OUT {
        ///	float pass_height;
        ///	vec3  pass_color;
        ///} gs_out;
        ///
        ///
        ///out vec4 out_Color;
        ///
        ///
        ///void main(void)
        ///{
        ///	if ( gs_out.pass_height &gt; info.y) discard;
        ///	out_Color = vec4(gs_out.pass_color*rgb, info.z);
        ///}*/ ähnelt.
        /// </summary>
        public static string building_frag {
            get {
                return ResourceManager.GetString("building_frag", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die #version 420 core
        ///
        ///layout(location = 0) in vec2  in_Position;
        ///layout(location = 1) in vec3  in_Colour;
        ///
        ///uniform vec3 scroll;
        ///uniform vec3 viewport;
        ///
        ///uniform float pos_x;
        ///uniform float pos_y;
        ///uniform float size;
        ///
        ///uniform vec3 rgb;
        ///uniform vec3 info;
        ///
        ////*
        ///out VS_OUT {
        ///	float pass_height;
        ///	vec3  pass_color;
        ///	} vs_out;
        ///*/
        ///out float pass_height;
        ///out vec3 pass_color;
        ///
        ///
        ///void main(void)
        ///{
        ///
        ///	//Um den Planeten biegen
        ///	//float alpha0 = info.x / size * 2.0 * 3.1415265358979323;
        ///	//float alp [Rest der Zeichenfolge wurde abgeschnitten]&quot;; ähnelt.
        /// </summary>
        public static string building_vert {
            get {
                return ResourceManager.GetString("building_vert", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die #version 420 core
        ///
        ///
        ///layout(binding = 0) uniform sampler2D tex;
        ///
        ///in vec4 pass_color;
        ///in vec2 texcoord;
        ///
        ///out vec4 out_Color;
        ///
        ///void main(void)
        ///{
        ///	out_Color = pass_color * texture2D(tex, texcoord);
        ///}
        /// ähnelt.
        /// </summary>
        public static string image_frag {
            get {
                return ResourceManager.GetString("image_frag", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die #version 420 core
        ///
        ///layout(location = 0) in vec3  in_Position;
        ///layout(location = 1) in vec4  in_Colour;
        ///layout(location = 2) in vec2  in_TexCoords;
        ///
        ///
        ///uniform vec3 viewport;
        ///
        ///out vec4 pass_color;
        ///out vec2 texcoord;
        ///
        ///
        ///void main(void)
        ///{
        ///	gl_Position = vec4( -1.0+viewport.x*in_Position.x*2.0, 1.0+viewport.y*(1.0-in_Position.y)*2.0, in_Position.z, 1.0);
        ///	pass_color = in_Colour;
        ///	texcoord = in_TexCoords;
        ///} ähnelt.
        /// </summary>
        public static string image_vert {
            get {
                return ResourceManager.GetString("image_vert", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die #version 420 core
        ///
        ///in vec4 pass_color;
        ///
        ///out vec4 out_Color;
        ///
        ///void main(void)
        ///{
        ///	out_Color = pass_color;
        ///}
        /// ähnelt.
        /// </summary>
        public static string mesh_frag {
            get {
                return ResourceManager.GetString("mesh_frag", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die #version 420 core
        ///
        ///layout(location = 0) in vec2  in_Position;
        ///layout(location = 1) in vec3  in_Colour;
        ///
        ///
        ///uniform vec2 pos;
        ///uniform vec3 scale;
        ///uniform vec4 col;
        ///
        ///out vec4 pass_color;
        ///
        ///
        ///void main(void)
        ///{
        ///	pass_color = vec4(in_Colour * col.xyz, col.w);
        ///	float py = max(min(in_Position.y, scale.z), -scale.z);
        ///	gl_Position = vec4(in_Position.x * scale.x *2.0 + pos.x, py * scale.y*2.0 + (1.0-pos.y), -0.7, 1.0);
        ///} ähnelt.
        /// </summary>
        public static string mesh_vert {
            get {
                return ResourceManager.GetString("mesh_vert", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die #version 420 core
        ///
        ///
        ///in vec4 color;
        ///
        ///out vec4 out_Color;
        ///
        ///
        ///void main(void)
        ///{
        ///	out_Color = color;
        ///} ähnelt.
        /// </summary>
        public static string particle2D_frag {
            get {
                return ResourceManager.GetString("particle2D_frag", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die #version 420 core
        ///
        ///layout(location = 0) in vec2 pos;
        ///layout(location = 1) in vec4 col;
        ///
        ///
        ///uniform vec3 scroll;
        ///uniform vec3 viewport;
        ///
        ///
        ///out vec4 color;
        ///
        ///
        ///void main(void)
        ///{
        ///	color = col;
        ///	
        ///	gl_Position = vec4(viewport.xy*(pos.xy - scroll.xy)*scroll.z, 0.0, 1.0);
        ///} ähnelt.
        /// </summary>
        public static string particle2D_vert {
            get {
                return ResourceManager.GetString("particle2D_vert", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die #version 420 core
        ///
        ///layout(binding = 0) uniform sampler2D texture;
        ///
        ///uniform float pos_x;
        ///uniform float pos_y;
        ///uniform vec3 rgb;
        ///uniform float size;
        ///
        ///in vec2 tex_coords;
        ///in vec2 pass_height;
        ///flat in vec3 pass_color;
        ///
        ///
        ///
        ///out vec4 out_Color;
        ///
        ///
        ///void main(void)
        ///{
        ///	vec3 tercol = pass_color;
        ///	if (pass_height.x != pass_height.y) // Ist nur bei Wasser der Fall --&gt; Dunkel-Hell Farbverlauf
        ///	{
        ///		tercol.xy *= 0.0125;
        ///		tercol += vec3(0.015*(pass_height.y-18.75*size),0.015*(pass_height.y-18.75*size) [Rest der Zeichenfolge wurde abgeschnitten]&quot;; ähnelt.
        /// </summary>
        public static string planet_frag {
            get {
                return ResourceManager.GetString("planet_frag", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die #version 420 core
        ///
        ///layout(location = 0) in vec2  in_Position;
        ///layout(location = 1) in float in_Terrain;
        ///layout(location = 2) in vec3  in_Colour;
        ///
        ///uniform vec3 scroll;
        ///uniform vec3 viewport;
        ///
        ///uniform float pos_x;
        ///uniform float pos_y;
        ///uniform vec3 rgb;
        ///uniform float size;
        ///
        ///out vec2 tex_coords;
        ///out vec2 pass_height;
        ///flat out vec3 pass_color;
        ///
        ///
        ///
        ///
        ///void main(void)
        ///{	
        ///	
        ///	//viewport.xy * + vec2(pos_x-scroll.x, pos_y-scroll.y))*scroll.z
        ///	vec2 vertex = in_Position;
        ///	bool isWater = false;
        ///	f [Rest der Zeichenfolge wurde abgeschnitten]&quot;; ähnelt.
        /// </summary>
        public static string planet_vert {
            get {
                return ResourceManager.GetString("planet_vert", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die #version 420 core
        ///
        ///
        ///in vec4 pass_color;
        ///
        ///out vec4 out_Color;
        ///
        ///void main(void)
        ///{
        ///	out_Color = pass_color;
        ///}
        /// ähnelt.
        /// </summary>
        public static string poly_frag {
            get {
                return ResourceManager.GetString("poly_frag", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die #version 420 core
        ///
        ///layout(location = 0) in vec3  in_Position;
        ///layout(location = 1) in vec4  in_Colour;
        ///
        ///
        ///uniform vec3 viewport;
        ///
        ///out vec4 pass_color;
        ///
        ///
        ///void main(void)
        ///{
        ///	gl_Position = vec4( -1.0+viewport.x*in_Position.x*2.0, 1.0+viewport.y*(1.0-in_Position.y)*2.0, in_Position.z, 1.0);
        ///	pass_color = in_Colour;
        ///} ähnelt.
        /// </summary>
        public static string poly_vert {
            get {
                return ResourceManager.GetString("poly_vert", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die #version 420 core
        ///
        /////layout(binding = 0) uniform sampler2D font;
        ///
        ///
        ///in Fragment {
        ///	vec4 rgba;
        ///	vec3 subCoords;
        ///	vec2 health;
        ///} frag;
        ///
        ///
        ///const float PI = 3.1415926535;
        ///out vec4 out_Color;
        ///
        ///
        ///void main(void)
        ///{
        ///	float radius = length(frag.subCoords.xy);
        ///	float fraction = (atan(-frag.subCoords.x, -frag.subCoords.y) / PI + 1.0)*0.5;
        ///	float alpha = 1.0;
        ///	
        ///	if (radius &lt;= 1.0 &amp;&amp; radius &gt;= 0.8) // Schildefrag.health.y
        ///	{
        ///		alpha = 0.45 * (1.0 - (abs(0.9-radius) * 10.0)*(abs(0.9-radius) * 10.0)); [Rest der Zeichenfolge wurde abgeschnitten]&quot;; ähnelt.
        /// </summary>
        public static string shield_frag {
            get {
                return ResourceManager.GetString("shield_frag", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die #version 420 core
        ///
        ///
        ///
        ///layout(points) in;
        ///layout(triangle_strip, max_vertices = 4) out;
        ///
        ///in Vertex {
        ///	vec4 rgba;
        ///	vec2 size;
        ///	vec2 health;
        ///	float shw;
        ///	//vec2 texCoords;
        ///} vex[1];
        ///
        ///out Fragment {
        ///	vec4 rgba;
        ///	vec3 subCoords;
        ///	vec2 health;
        ///} frag;
        ///
        ///
        ///void main(void)
        ///{
        ///	//Farbe bleibt fÃ¼r alle Vertices gleich.
        ///	frag.rgba = vex[0].rgba;
        ///	frag.health = vex[0].health;
        ///	//frag.health = vec2(0.4, 0.85);
        ///	
        ///	//oben links
        ///	frag.subCoords = vec3(-1.0, +1.0, 1.0/vex[0].shw);
        ///	gl_Position =  [Rest der Zeichenfolge wurde abgeschnitten]&quot;; ähnelt.
        /// </summary>
        public static string shield_geom {
            get {
                return ResourceManager.GetString("shield_geom", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die #version 420 core
        ///
        ///layout(location = 0) in vec3 pos;
        ///layout(location = 1) in vec2 health;
        ///layout(location = 2) in vec4 rgba;
        ///
        ///
        ///uniform vec3 scroll;
        ///uniform vec3 viewport;
        ///
        ///
        ///out Vertex {
        ///	vec4 rgba;
        ///	vec2 size;
        ///	vec2 health;
        ///	float shw;
        ///	//vec2 texCoords;
        ///} vex;
        ///
        ///
        ///void main(void)
        ///{
        ///	vex.health = health;
        ///	vex.rgba = rgba;
        ///	vex.shw = 1.0 / (pos.z);
        ///	vex.size = viewport.xy*(pos.z*scroll.z*0.55 + 5.0);
        ///	gl_Position = vec4( viewport.xy*(pos.xy - scroll.xy)*scroll.z, -0.5, 1.0);
        ///	
        ///	//ve [Rest der Zeichenfolge wurde abgeschnitten]&quot;; ähnelt.
        /// </summary>
        public static string shield_vert {
            get {
                return ResourceManager.GetString("shield_vert", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die #version 420 core
        ///
        /////layout(binding = 0) uniform sampler2D font;
        ///
        ///
        ///in Fragment {
        ///	vec4 rgba;
        ///} frag;
        ///
        ///
        ///out vec4 out_Color;
        ///
        ///
        ///void main(void)
        ///{
        ///	out_Color = frag.rgba;
        ///} ähnelt.
        /// </summary>
        public static string shot_frag {
            get {
                return ResourceManager.GetString("shot_frag", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die #version 420 core
        ///
        ///
        ///
        ///layout(points) in;
        ///layout(line_strip, max_vertices = 2) out;
        ///
        ///in Vertex {
        ///	vec3 rgb;
        ///	vec2 alphas;
        ///	vec2 p0;
        ///	vec2 p1;
        ///} vex[1];
        ///
        ///out Fragment {
        ///	vec4 rgba;
        ///} frag;
        ///
        ///
        ///void main(void)
        ///{
        ///	//Farbe bleibt fÃ¼r alle Vertices gleich.
        ///	frag.rgba = vec4(vex[0].rgb, vex[0].alphas.x);
        ///	
        ///	gl_Position = vec4(vex[0].p0, 0.0, 1.0);
        ///	EmitVertex();
        ///	
        ///	frag.rgba.a = vex[0].alphas.y;
        ///	gl_Position = vec4(vex[0].p1, 0.0, 1.0);
        ///	EmitVertex();
        ///	
        ///	
        ///	/*
        ///	//oben links
        ///	frag.sub [Rest der Zeichenfolge wurde abgeschnitten]&quot;; ähnelt.
        /// </summary>
        public static string shot_geom {
            get {
                return ResourceManager.GetString("shot_geom", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die #version 420 core
        ///
        ///layout(location = 0) in vec4 pos;
        ///layout(location = 1) in vec3 rgb;
        ///layout(location = 2) in vec2 alphas;
        ///
        ///
        ///uniform vec3 scroll;
        ///uniform vec3 viewport;
        ///
        ///
        ///out Vertex {
        ///	vec3 rgb;
        ///	vec2 alphas;
        ///	vec2 p0;
        ///	vec2 p1;
        ///} vex;
        ///
        ///
        ///void main(void)
        ///{
        ///	vex.rgb = rgb;
        ///	vex.alphas = alphas;
        ///	vex.p1 = viewport.xy*(pos.xy - scroll.xy)*scroll.z;
        ///	vex.p0 = viewport.xy*(pos.zw - scroll.xy)*scroll.z;
        ///	
        ///	gl_Position = vec4(vex.p0, 0.0, 1.0);
        ///	//vex.size = vec2(viewport.xy)*pos.z*2.0;        /// [Rest der Zeichenfolge wurde abgeschnitten]&quot;; ähnelt.
        /// </summary>
        public static string shot_vert {
            get {
                return ResourceManager.GetString("shot_vert", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die #version 420 core
        ///
        ///in vec2 space;
        ///in vec2 space1;
        ///in vec2 space2;
        ///in vec2 space3;
        ///
        ///out vec4 out_Color;
        ///
        ///layout(binding = 0) uniform sampler2D stars;
        ///layout(binding = 1) uniform sampler2D star_brightness;
        ///layout(binding = 2) uniform sampler2D nebulae1;
        ///layout(binding = 3) uniform sampler2D nebulae2;
        ///layout(binding = 4) uniform sampler2D dominanceMap;
        ///
        ///const float DOMINANCE_MAP_SCALING = 1.0/ (25.0);
        ///
        ///void main(void)
        ///{
        ///
        ///    vec4 dominance = texture2D(dominanceMap, (space * DOMINANCE_MAP_SC [Rest der Zeichenfolge wurde abgeschnitten]&quot;; ähnelt.
        /// </summary>
        public static string space_frag {
            get {
                return ResourceManager.GetString("space_frag", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die #version 420 core
        ///
        ///layout(location = 0) in vec2 pos;
        ///
        ///uniform vec3 viewport;
        ///uniform vec3 scroll;
        ///
        ///out vec2 space;
        ///out vec2 space1;
        ///out vec2 space2;
        ///out vec2 space3;
        ///
        ///void main(void)
        ///{
        ///	gl_Position = vec4(pos, 0.6, 1.0);
        ///	
        ///	space = ((viewport.xy * pos / scroll.z) + scroll.xy )*0.001;
        ///	space1 = ((viewport.xy * pos / scroll.z) + scroll.xy * 0.75 )*0.001;
        ///	space2 = -((viewport.xy * pos / scroll.z) + scroll.xy * 0.5 )*0.001;
        ///	space3 = ((viewport.xy * pos / scroll.z) + scroll.xy * 0.25 )*0.001 [Rest der Zeichenfolge wurde abgeschnitten]&quot;; ähnelt.
        /// </summary>
        public static string space_vert {
            get {
                return ResourceManager.GetString("space_vert", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die #version 420 core
        ///
        ///layout(binding = 0) uniform sampler2D font;
        ///
        ///
        ///in Fragment {
        ///	vec4 rgba;
        ///	vec2 texCoords;
        ///} frag;
        ///
        ///
        ///
        ///out vec4 out_Color;
        ///
        ///
        ///void main(void)
        ///{
        ///	out_Color = frag.rgba * texture2D(font, frag.texCoords);// * frag.rgba;
        ///	if(out_Color.a &lt; 0.05) discard;
        ///	//out_Color = vec4(frag.texCoords, 1.0, 1.0) * frag.rgba;
        ///} ähnelt.
        /// </summary>
        public static string text_frag {
            get {
                return ResourceManager.GetString("text_frag", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die #version 420 core
        ///
        ///layout(points) in;
        ///layout(triangle_strip, max_vertices = 4) out;
        ///
        ///in Vertex {
        ///	vec4 rgba;
        ///	vec2 size;
        ///	vec2 texCoords;
        ///} vex[1];
        ///
        ///out Fragment {
        ///	vec4 rgba;
        ///	vec2 texCoords;
        ///} frag;
        ///
        ///
        ///void main(void)
        ///{
        ///	//Farbe bleibt fÃ¼r alle Vertices gleich.
        ///	frag.rgba = vex[0].rgba;
        ///	
        ///	//Oben links
        ///	frag.texCoords = vex[0].texCoords;
        ///	gl_Position = gl_in[0].gl_Position;
        ///	EmitVertex();
        ///	
        ///	//unten links
        ///	frag.texCoords = vex[0].texCoords + vec2(0.0, 1.0/16.5);
        ///	gl_Position = [Rest der Zeichenfolge wurde abgeschnitten]&quot;; ähnelt.
        /// </summary>
        public static string text_geom {
            get {
                return ResourceManager.GetString("text_geom", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die #version 420 core
        ///
        ///layout(location = 0) in vec4 rgba;
        ///layout(location = 1) in float chars;
        ///layout(location = 2) in vec3 pos;
        ///
        ///
        ///uniform vec3 viewport;
        ///
        ///
        ///out Vertex {
        ///	vec4 rgba;
        ///	vec2 size;
        ///	vec2 texCoords;
        ///} vex;
        ///
        ///
        ///void main(void)
        ///{
        ///	gl_Position = vec4( -1.0+viewport.x*pos.x*2.0, 1.0+viewport.y*(1.0-pos.y)*2.0, -0.5, 1.0);
        ///	
        ///	vex.size = vec2(viewport.xy)*pos.z*2.0;
        ///	vex.rgba = rgba;
        ///	vex.texCoords = vec2( mod(chars, 16.0)/16.0, floor(chars/16.0)/16.0 );
        ///} ähnelt.
        /// </summary>
        public static string text_vert {
            get {
                return ResourceManager.GetString("text_vert", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die #version 420 core
        ///
        ///in vec4 pass_color;
        ///
        ///out vec4 out_Color;
        ///
        ///void main(void)
        ///{
        ///	out_Color = pass_color;
        ///	//out_Color = vec4(1.0, 1.0, 1.0, 1.0);
        ///}
        /// ähnelt.
        /// </summary>
        public static string unit_frag {
            get {
                return ResourceManager.GetString("unit_frag", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die #version 420 core
        ///
        ///layout(location = 0) in vec2  in_Position;
        ///layout(location = 1) in vec3  in_Colour;
        ///
        ///
        ///uniform vec3 pos;
        ///uniform vec4 col;
        ///uniform vec3 scale;
        /////uniform vec3 shields;
        ///
        ///
        ///out vec4 pass_color;
        ///
        ///
        ///void main(void)
        ///{
        ///	pass_color = vec4(in_Colour * col.xyz * 0.75 + 0.25, col.w);
        ///	
        ///	vec2 vertex = vec2(sin(pos.z)*in_Position.x + cos(pos.z)*in_Position.y, sin(pos.z)*in_Position.y - cos(pos.z)*in_Position.x)*scale.x;
        ///	
        ///	gl_Position = vec4( scale.yz * (vertex + pos.xy) , -0.4, 1.0) [Rest der Zeichenfolge wurde abgeschnitten]&quot;; ähnelt.
        /// </summary>
        public static string unit_vert {
            get {
                return ResourceManager.GetString("unit_vert", resourceCulture);
            }
        }
    }
}
